#include "Map.h"
#include <iostream>
#include <stdlib.h>
#include <ctime>
#include <sstream>
#include<vector>
using namespace std;

static const int MAX_DOOR = 1;		//Number of maximum doors generated by the random map
Map::Map()
{
}

Map::Map(int l, int h) {
	// Initialize variables
	length = l + 2;
	height = h + 2;


	// Create 2D array
	mArr = new char*[length];
	for (int i = 0; i < length; i++)
		mArr[i] = new char[length];

	// Fill the array with empty spaces (=)
	for (int i = 0; i < length; i++) {
		for (int j = 0; j < height; j++)
			mArr[i][j] = '=';
		// Set up initial walls around
		for (int i = 0; i < height; i++) {
			mArr[i][0] = '|';
			mArr[i][height - 1] = '|';
		}
		for (int j = 0; j < length; j++) {
			mArr[0][j] = '-';
			mArr[length - 1][j] = '-';
		}
		// Set up corners
		mArr[0][0] = '+';
		mArr[length - 1][0] = '+';
		mArr[0][height - 1] = '+';
		mArr[length - 1][height - 1] = '+';
	}


}

void showMap(Map m)
{
	for (int i = 0; i < m.length; i++)
	{
		for (int j = 0; j < m.height; j++)
		{
			cout << m.mArr[i][j];
		}
		cout << endl;
	}
}


string Map::showMap() {
	// Create string stream to create data
	stringstream sstream;
	for (int i = 0; i < length; i++)
		sstream << endl << endl << endl;

	for (int i = 0; i < height; i++) {
		for (int j = 0; j < length; j++)
			sstream << mArr[i][j] << " ";
		sstream << endl << endl;
	}

	return sstream.str();
}

bool validatePath(Map m)
{
	for (int i = 0; i < m.length; i++)
	{
		for (int j = 0; j < m.height; j++)
		{
			if (m.mArr[i][j] == 'd') // 'd' is for door
			{
				return true;
			}
		}
	}
	return false;
}

void fillCell(int x, int y, char obj, Map &m)
{
	if (obj == 'd') {
		Pair doorIndices;
		doorIndices.x = x;
		doorIndices.y = y;
		m.insertDoorIndices(doorIndices);
	}
	m.mArr[x][y] = obj;
}

bool isOccupied(int x, int y, Map m)
{
	if (m.mArr[x][y] != '=')
	{
		return true;
	}
	return false;
}

int getLength(Map m)
{
	return m.length;
}
int getHeight(Map m)
{
	return m.height;
}

char** getMapElements(Map map)
{
	return map.mArr;
}

void setLength(int x, Map map) {
	map.length = x;
}

void setHeight(int y, Map map) {
	map.height = y;
}


void makeRandomMap(Map &m)
{	
	int characterStart = 0;
	int maxDoor = 0;
	srand(time(NULL));
	for (int i = 1; i < getLength(m) - 1; i++)
	{

		for (int j = 1; j < getHeight(m) - 1; j++)
		{

			int num = (rand() % 100);
			if (num < 80)
			{
				fillCell(i, j, '=', m); //'=' is free space
			}
			else if (num >= 80 && num < 85)
			{
				if (characterStart == 0) {
					fillCell(i, j, '@', m);	//'@' is for character
					characterStart++;
				}
				else if (maxDoor < MAX_DOOR)	
				{
					fillCell(i, j, 'd', m); // 'd' is for door
					maxDoor++;
				}
				else
					fillCell(i, j, '=', m); // free space for limit door
			}

			else if (num >= 85 && num < 90) {
				fillCell(i, j, 'c', m);	//'c' is for chest
			}

			else if (num >= 90 && num < 95) {
				fillCell(i, j, 'm', m);	//m is for monster
			}

			else
			{
				fillCell(i, j, '*', m);	//* is for wall
			}

		}

	}
}

ostream & operator<<(ostream &stream, Map &m)
{
	// TODO: insert return statement here
	stream << m.showMap();
	return stream;
}




// Move the character in the game
bool Map::move(char dir, Map m)
{
	bool firstMove = true;
	for (int i = 1; i < getLength(m) - 1; i++)
	{

		for (int j = 1; j < getHeight(m) - 1; j++)
		{
			if (m.mArr[i][j] == '@')
			{
				tempX = i;
				tempY = j;
			}
		}
	}
	playerX = tempX;
	playerY = tempY;

	mArr[tempX][tempY] = current;

	if (dir == 'd' || dir == 'D')
		tempY = tempY + 1;
	else if (dir == 'w' || dir == 'W')
		tempX = tempX - 1;
	else if (dir == 'a' || dir == 'A')
		tempY = tempY - 1;
	else if (dir == 's' || dir == 'S')
		tempX = tempX + 1;
	else if (dir == 'i' || dir == 'I') {

	}

	// Moveable location
	if (mArr[tempX][tempY] == '=') {
		playerX = tempX;
		playerY = tempY;
		if (firstMove)
			fillCell(playerX, playerY, '=', m);
	}
	// Moved onto door goes to next map.
	else if (mArr[tempX][tempY] == 'd') {
		playerX = tempX;
		playerY = tempY;
		current = mArr[playerX][playerY];
		mArr[playerX][playerY] = '@';

		notify();
		//for (unsigned int i = 0; i < m.doorIndices.size(); i++) {	//Finding the door, which will open the next map.
		//	if (playerX == m.doorIndices[i].x && playerY == m.doorIndices[i].y) {
		//	}
		//}
		return true;
	}

	current = mArr[playerX][playerY];
	mArr[playerX][playerY] = '@';

	notify();
	return false;
}

void Map::insertDoorIndices(Pair doorIndices1)
{
	doorIndices.push_back(doorIndices1);
}










/*
int const MAP_LENGTH = 2;
int const MAP_length = 2;

char map[MAP_LENGTH][MAP_length] = {
{ ' ', ' ' },
{ ' ', ' ' }
};

bool Map::validatePath()
{
for (int i = 0; i < MAP_LENGTH; i++)
{
for (int j = 0; j < MAP_length; j++)
{
if (map[i][j] = 'd') // 'd' is for door
{
return true;
}
else
return false;
}
}
}

void Map::fillCell(int x, int y, char obj)
{
map[x][y] = obj;
}

bool Map::isOccupied(int x, int y)
{
if (map[x][y] != '=')
{
return true;
}
return false;
}

*/

